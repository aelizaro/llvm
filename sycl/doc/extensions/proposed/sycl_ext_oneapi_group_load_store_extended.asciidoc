= sycl_ext_oneapi_group_load_store

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]
:language: {basebackend@docbook:c++:cpp}

== Introduction

IMPORTANT: This specification is a draft.


== Notice

[%hardbreaks]
Copyright (c) 2022 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.

== Dependencies

This extension is written against the SYCL 2020 specification, Revision 6.
All references below to the "core SYCL specification" or to section numbers in
the SYCL specification refer to that revision.

This extension also depends on the following other SYCL extensions:

* link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/proposed/sycl_ext_oneapi_group_sort.asciidoc[
  sycl_ext_oneapi_group_sort] (`group_with_scratchpad` class used as GroupHelper).

* link:../experimental/sycl_ext_oneapi_properties.asciidoc[
  sycl_ext_oneapi_properties].

== Overview

This extension defines free functions for load/store operations within work
group scope.

== Single Value Functions

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

// Load API scalar
template<typename Group, typename InputIteratorT,
         typename OutputT, typename Properties = properties<>>
void group_load(Group g, InputIteratorT in_ptr,
                      OutputT& out, Properties = {}); (1)

// Store API scalar
template<typename Group, typename InputT,
         typename OutputIteratorT, typename Properties = properties<>>
void group_store(Group g, const InputT& in,
                      OutputIteratorT out_ptr, Properties = {}); (2)

}
----

(1) _Preconditions_: `in_ptr` must be the same for all work-items
in the group.

_Constraints_: Only available if `Group` is a work-group or sub-group.

_Effects_: Loads single element from `in_ptr` to `out`.
Properties TBD (setting boundary values or limiting numbers of work items).


(2) _Preconditions_: `out_ptr` must be the same for all work-items
in the group.

_Constraints_: Only available if `Group` is a work-group or sub-group.

_Effects_: Stores single element `in` to `out_ptr`.
Properties TBD (setting boundary values or limiting numbers of work items).

== `sycl::vec` Functions

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

// Load API sycl::vec overload
template<typename Group, typename InputIteratorT,
         typename OutputT, int N, typename Properties = properties<>>
void group_load(Group g, InputIteratorT in_ptr,
                      sycl::vec<OutputT, N>& out, Properties = {}); (3)

// Store API sycl::vec overload
template<typename Group, typename InputT, int N,
         typename OutputIteratorT, typename Properties = properties<>>
void group_store(Group g, const sycl::vec<InputT, N>& in,
                      OutputIteratorT out_ptr, Properties = {}); (4)

}
----

(3) _Preconditions_: `in_ptr` must be the same for all work-items
in the group.

_Constraints_: Only available if `Group` is a work-group or sub-group.

_Effects_: Loads `N` elements from `in_ptr` to `out`
using the `g` group object. Properties can specify data placement.

(4) _Preconditions_: `out_ptr` must be the same for all work-items
in the group.

_Constraints_: Only available if `Group` is a work-group or sub-group.

_Effects_: Stores `N` elements from `in` vec to `out_ptr`
using the `g` group object. Properties can specify data placement.

== Functions with fixed-size arrays

This API provides the following features:

* load/store with temporary memory buffer, which can be passed via GroupHelper
such as `group_with_scratchpad` link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/proposed/sycl_ext_oneapi_group_sort.asciidoc#group-helper[group_with_scratchpad description from sort over group proposal]

* load/store flexible amount of elements per work item as sycl::span

* specify data placement type via properties (6) or extra options such as
setting boundary values or limiting numbers of work items (TODO in design
considerations)

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

// Load API
template<typename GroupHelper, typename InputIteratorT, typename OutputT,
        std::size_t ElementsPerWorkItem, typename Properties = properties<>>
void group_load(GroupHelper gh, InputIteratorT in_ptr,
                sycl::span<OutputT, ElementsPerWorkItem> out, Properties = {}); (6)


// Store API
template<typename GroupHelper, typename OutputIteratorT, typename InputT,
        std::size_t ElementsPerWorkItem, typename Properties = properties<>>
void group_store(GroupHelper gh, OutputIteratorT out_ptr,
                  sycl::span<InputT, ItemsPerWorkItem> in, Properties = {}); (7)


// Properties:
enum class group_algorithm_data_placement {
  blocked,
  striped
};

// Support memory function to define the needed amount of temporary memory
// needed (name TBD)

template<typename T, std::size_t ElementsPerWorkItem>
constexpr std::size_t memory_required(sycl::memory_scope scope,
                                      std::size_t block_size); (8)

}
----

(6) _Preconditions_: `in_ptr` must be the same for all work-items
in the group. `out` must be a `sycl::span` made from a pointer to the private memory space.

_Constraints_: Only available if `GroupHelper` is a
work-group or sub-group or `GroupHelper` was created with a
work-group or sub-group and some associated scratch space
(link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/proposed/sycl_ext_oneapi_group_sort.asciidoc[`group_with_scratchpad`]).

_Effects_: Loads `ElementsPerWorkItem` elements from `in_ptr` to `out`
using the `gh` group helper object. Properties can specify data placement.

(7) _Preconditions_: `out_ptr` must be the same for all work-items
in the group. `in` must be a `sycl::span` made from a pointer to the private memory space.

_Constraints_: Only available if `GroupHelper` is a
work-group or sub-group or `GroupHelper` was created with a
work-group or sub-group and some associated scratch space
(link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/proposed/sycl_ext_oneapi_group_sort.asciidoc[`group_with_scratchpad`]).

_Effects_: Stores `ElementsPerWorkItem` elements from `in` span to `out_ptr`
using the `gh` group helper object. Properties can specify data placement.

(8)_Effects_: Returns size of temporary memory (in bytes) that is required for
scratch space in `GroupHelper`. Result depends on type `T`, `ElementsPerWorkItem`
and the scope parameter: use sycl::memory_scope::work_group to get memory size
required for each work-group; use sycl::memory_scope::sub_group to get memory
size required for each sub-group. If other scope values are passed, behavior is
unspecified.

== Usage Examples

1.Example shows the simplest case without local memory usage of blocked load
of global memory from `input` to the private array `data` and store it back to
`output`

[source,c++]
----
namespace sycl_exp = sycl::ext::oneapi::experimental;

q.submit([&](sycl::handler& cgh) {
    cgh.parallel_for(
        sycl::nd_range<1>(global_size, local_size),
        [=](sycl::nd_item<1> item) {
            T data[items_per_thread];

            sycl_exp::group_load(item.get_group(), input, sycl::span{ data });

            // Work with data...

            sycl_exp::group_store(item.get_group(), output, sycl::span{ data });
        });
});
----

2.Example shows the simple case of blocked load of global memory from `input` to
the private array `data` and store it back to `output`
The temporary memory is allocated via `sycl::local_accessor`

[source,c++]
----
namespace sycl_exp = sycl::ext::oneapi::experimental;

q.submit([&](sycl::handler& cgh) {
    constexpr auto temp_memory_size = sycl_exp::memory_required<T, items_per_thread>(
        sycl::memory_scope::work_group, block_size);
    sycl::local_accessor<std::byte> buf(temp_memory_size, cgh);
    cgh.parallel_for(
        sycl::nd_range<1>(global_size, local_size),
        [=](sycl::nd_item<1> item) {
            T data[items_per_thread];
            std::byte* buf_ptr = buf.get_pointer().get();
            sycl_exp::group_with_scratchpad gh{ item.get_group(),
                                                sycl::span{ buf_ptr, temp_memory_size } };

            sycl_exp::group_load(gh, input, sycl::span{ data });

            // Work with data...

            sycl_exp::group_store(gh, output, sycl::span{ data });
        });
});
----

3.Example shows the case of striped load of global memory from `input` to
the private array `data` and store it back to `output`
The temporary memory is allocated via `group_local_memory` API, described in
link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/supported/sycl_ext_oneapi_local_memory.asciidoc[sycl_ext_oneapi_local_memory]

[source,c++]
----
namespace sycl_exp = sycl::ext::oneapi::experimental;

q.submit([&](sycl::handler& cgh) {
    constexpr auto temp_memory_size = sycl_exp::memory_required<T, items_per_thread>(
        sycl::memory_scope::work_group, block_size);
    cgh.parallel_for(
        sycl::nd_range<1>(block_count * block_size, block_size),
        [=](sycl::nd_item<1> item) {
            T data[items_per_thread];
            auto scratch =
                sycl::ext::oneapi::group_local_memory<std::byte[temp_memory_size]>(
                    item.get_group());
            std::byte* buf_ptr = (std::byte*)(scratch.get());

            sycl_exp::group_with_scratchpad gh{ item.get_group(),
                                                sycl::span{ buf_ptr, temp_memory_size } };

            sycl_exp::group_load(gh, input, sycl::span{ data },
                                 sycl::properties<sycl_exp::data_placement<sycl_exp::striped>>{});

            // Work with data...

            sycl_exp::group_store(gh, output, sycl::span{ data },
                                  sycl::properties<sycl_exp::data_placement<sycl_exp::striped>>{});
        });
});
----

== Design Considerations

* consider extending sycl::span to std::mdspan for C++23 for 2d and 3d kernels

* TODO: consider adding extra properties for setting boundary values or limiting
number of work-items
